---
layout: single
title: "Exceptional Control Flow(ECF) - Process"
categories: system-sw 
---

# Process

안녕하세요. 이번 포스팅은 ECF: Introduction의 다음편인 Process편입니다.

<br>

## 프로그램 실행의 환상과 현실

현대 컴퓨터에서 프로그램을 실행할 때, 우리는 마치 그 프로그램이 프로세서와 메모리를 독점하여 사용하는 것처럼 느낍니다. 예를 들어 윈도우에서 Word 프로그램으로 문서 작업을 하고 있다면, 프로세서가 Word의 명령어들을 순차적으로, 중단 없이 실행하는 것처럼 보입니다.

하지만 이것은 **운영체제가 제공하는 정교한 추상화**입니다. 실제로는 그 이면에서 OS kernel이 끊임없이 동작하고 있습니다:

- 키보드와 마우스 입력에 대한 **interrupt handler**가 실행됩니다
- 가상 메모리 시스템의 **page fault handler**가 필요한 페이지를 메모리에 적재합니다
- 다른 프로그램들로의 **context switching**이 사용자 눈에 보이지 않게 발생합니다

이 모든 것이 우리 눈에 보이지 않게 일어나면서, Word 프로그램만 실행되고 있다는 착각을 제공합니다.

### 질문: 동시성과 병렬성

여기서 한 가지 생각해볼 질문이 있습니다:

> **"여러 프로그램이 동시에 실행된다"는 것의 의미는 무엇일까요?**

전통적인 운영체제 이론에서는 **싱글 프로세서** 환경을 가정하고, context switching을 통해 여러 프로그램이 마치 동시에 실행되는 것처럼 보이게 합니다. 하지만 실제로는 어느 한 순간에 하나의 프로그램만 실행되고, OS가 매우 빠르게 전환하면서 동시 실행의 환상을 만들어냅니다.

반면 현대 시스템은 **멀티 프로세서/멀티 코어** 환경이 주류입니다. 이 경우:

- 일부 프로그램들은 **실제로 동시에(parallel)** 실행됩니다
- 하지만 실행 중인 프로그램 수가 CPU 코어 수보다 많다면, 여전히 일부는 **동시에 실행되는 것처럼 보이는(concurrent)** 것입니다
- 즉, 진정한 병렬성(parallelism)과 시분할에 의한 동시성(concurrency)이 함께 존재합니다

## 이번 포스팅에서 다룰 내용

이번 포스팅에서는 운영체제의 모든 메커니즘을 다루지는 않지만, 프로세스라는 추상화의 핵심 개념들을 살펴봅니다:

1. **독립적 논리 제어 흐름(Logical Control Flow)**: 프로그램이 프로세서를 독점한다는 착각을 제공
2. **사적 주소 공간(Private Address Space)**: 프로그램이 메모리를 독점한다는 착각을 제공

이러한 추상화들이 어떻게 동작하고, 왜 중요한지 함께 알아보겠습니다. 


## Logical Control Flow

각 프로세스는 시스템에 여러 프로그램들이 동시에 동작하고 있음에도 불구하고, 마치 프로세서를 혼자서 사용하는 것처럼 느낍니다.<br> 만일 프로그램의 실행을 단일 스텝으로 실행하기 위해서 debugger를 사용하면, executable object 내에 들어 있거나 runtime에 동적으로 링크된 shared object 내에 있는 instruction에 PC (Program Counter) 값들이 대응되는 것을 관찰할 수 있습니다.<br> 이런 PC 값들의 배열을 논리적 제어흐름 또는 간단히 논리흐름이라고 부릅니다.

아래 그림은 단일 프로세서에서 세 개의 프로세스를 실행하는 시스템에 대해 표현한 것입니다.<br> 이 프로세서에서 물리적인 제어흐름은 프로세서에 대해서 한 개씩 세 개의 논리흐름으로 나누어집니다.<br> 각 수직선은 어떤 프로세스에 대한 논리적인 흐름의 일부를 나타냅니다.<br> 아래 그림에서 이 세 개의 논리 흐름은 서로 중첩되지 않습니다. (단일 프로세서에 대해 생각하는 것이므로) 

아래 그림의 요점은 하나의 프로세서를 사용해서 여러 프로세스들이 교대로 돌아간다는 점입니다.<br> 각 프로세스는 자신의 흐름 일부분을 실행하고 나서 다른 프로세스들로 순서를 바꾸어 실행되는 동안 선점됩니다. (mean: 선점된다 → 일시적으로 정지된다.) <br>이 프로세스들 중에서 하나의 context에서 실행되는 프로그램은 마치 프로세서를 배타적으로 소유한 것처럼 보입니다. 

![alt text](/assets/images/2025-12-4-ch8-2-process/logical_control_flow.png)

## Concurrent Flow

논리흐름은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 가집니다. Exception handler, Process, Signal handler, Thread는 모두 논리흐름의 예시입니다.

자신의 실행시간이 다른 흐름과 겹치는 논리흐름을 *동시성 흐름 (Concurrent Flow)*이라고 부릅니다.<br> 이 두 흐름은 동시에 실행된다고 말합니다. 위 그림에서 Process A와 Process B는 동시에 실행되는 상황이고, Process B와 Process C는 동시에 실행되는 것이 아닙니다.<br> 왜냐하면 B의 마지막 instruction이 C의 첫 번째 instruction 전에 실행되기 때문입니다.

여러 흐름이 동시에 실행되는 현상을 *동시성 (Concurrency)*이라고 말합니다.<br> 또한 프로세스가 다른 프로세스들과 교대로 실행된다는 개념은 *multitasking*이라고 말합니다.<br> 한 프로세스가 자신의 흐름 일부를 실행하는 매 시간 주기를 *time slice*라고 합니다.<br> 그래서 *multitasking*을 *time slicing*이라고 부르기도 합니다.<br> 위 그림에서 Process A에 대한 흐름은 2개의 time slice로 구성됩니다.<br>

동시성 흐름에 대한 개념은 시스템의 프로세서 코어 수나 프로세서 갯수와는 무관합니다. <br>만일 두 흐름이 시간상으로 중첩되면 동시적으로 실행되는 것입니다. <br>프로세서의 어느 한 코어에서 2 개의 프로세스가 실행된다고 해도 시간상 중첩되면 동시적이라고 할 수 있습니다. <br>하지만 여기서 구별해야하는 중요한 개념이 있습니다. <br>바로 *병렬 흐름 (parallel flows)* 입니다. <br>만일 2개의 process가 서로 다른 프로세서 코어나 프로세서(numa)에서 동시에 돌아가고 있다면 이는 동시 실행이자, 병렬 실행입니다.



## Contexts Switches

여기에서는 context switch가 간단하게 어떤 상황에서 발생하는지 간단하게 소개하도록 하겠습니다.

운영체제의 커널은 멀티태스킹을 context switch라고 알려진 예외적 흐름을 이용해서 구현합니다.
커널은 각 프로세스에 대한 context를 가지고 있습니다. context는 선점되어서 중단된 프로세스를 나중에 다시 실행가기 위해 커널이 저장해 두는 상태 정보입니다. 여기에는 GPR (general purpose register), SPR (special purpose register), page table과 같은 커널 구조체, 현재 프로세스의 정보를 담고 있는 프로세스 테이블, 그리고 프로세스가 열어 둔 파일들의 정보를 담고 있는 파일 테이블과 같은 여러 커널 데이터 구조들도 포함됩니다. 이런 내용들이 process context를 구성하게 됩니다.

프로세스 실행 특정 시점에 커널은 현재 프로세스를 선점하거나 선점된 다른 프로세스를 다시 시작하는 것을 결정합니다. 이런 결정은 **스케줄링**이라고 말합니다. 커널에 있는 **스케줄러**에 의해 진행됩니다.
커널이 실행할 새로운 프로세스를 선택하는 것을 커널이 프로세스를 스케쥴링했다고 말합니다. 커널이 실행할 새로운 프로세스를 스케쥴링했다면 현재 실행중인 프로세스를 선점하고 CPU의 제어권을 새로운 프로세스에게 넘겨줍니다. 제어권을 넘겨줄 때 context switching이 발생합니다. 

Context switching에 대해 장황하게 설명했는데 요약하면 아래와 같습니다.
1. 현재 프로세스의 context를 저장한다.
2. 새롭게 실행할 프로세스의 context를 불러온다.
3. CPU의 제어권을 새로운 프로세스에게 넘겨준다.

Context switching은 프로세스가 system call을 호출했고, 그 system call을 기다리는 상황에서도 발생할 수 있습니다.
예를 들어서 `read` system call을 호출했고, 디스크에서 데이터를 읽어 와야 하는 상황이면, 커널은 디스크 I/O를 수행할 것입니다.
하지만 disk I/O는 프로세서의 속도보다 느리기 때문에 멍하니 기다리는 상황이 벌어질 것입니다. 이렇게 기다리는 상황에서도 context switching이 발생할 수 있다는 의미입니다. 이런 방법을 사용하는 이유는 멍하니 기다리는 것보다 그 시간에 다른 작업을 수행하는 것이 프로세서를 더 효율적으로 사용하는 것이기 때문입니다.

또 다른 예시로는 `sleep` system call이 있습니다. `sleep`을 호출한 프로세스를 일정 시간 동안 스스로 잠재워 달라고 명시적으로 요청하는 system call입니다. 프로세스가 `sleep`된 상태라면 이 프로세스는 CPU를 계속 점유하고 있을 필요가 없습니다. 커널은 이 프로세스를 `sleep` 상태로 바꾸고 다른 프로세스로 context switching을 합니다.

일반적으로 길게 block하는 system call이 아니라고 해도 커널은 system call을 호출한 프로세스로 return하지 않고 다른 프로세스로 context switching하는 것을 결정할 수도 있습니다. 예를 들어서 짧은 write system call을 호출했다고 생각해봅시다. 특정 프로세스가 로그를 file에 쓰기 위해서 10byte 정도 되는 내용을 write하는 system call을 호출했습니다. write 처리 시간이 매우 짧아서 block되는 것이 없이 곧바로 끝나게 됩니다. 하지만 해당 프로세스의 time slice가 끝날 무렵이라면 커널은 write system call을 호출한 프로세스로 return하는 것 말고도 다른 프로세스로 context switching하는 것을 선택할 수도 있다는 의미입니다.

Context switching은 인터럽트로 인해 발생할 수도 있습니다. 대부분의 시스템에서는 주기적으로 타이머 인터럽트를 발생시키는 HW가 존재하고 1ms 혹은 10ms마다 인터럽트가 발생하게 됩니다. 타이머 인터럽트가 들어올 때마다 커널은 "지금 실행 중인 프로세스가 충분히 오래 돌았다"라고 판단하면, 그 시점을 스케줄링 포인트로 삼아서 다른 프로세스로 context switching할 수도 있다는 의미입니다. 




![alt text](/assets/images/2025-12-4-ch8-2-process/anatomy_of_a_process_context_switching.png)

간단하게 `read` system call을 호출한 상태에서 Context switching이 발생하는 예시를 살펴보도록 하겠습니다.
아래 예시는 스케쥴러 정책에 따라 달라질 수 있습니다.
아래 그림에서 Process A의 user code에서 `read` system call을 호출했습니다. `read` system call에 대한 callback 함수가 kernel에 존재하고 이 코드는 kernel mode에서 수행되게 됩니다. `read`에 대한 callback 함수가 `read`를 위한 작업을 마치고 disk controller에게 해당 내용을 메모리에 올리라는 작업을 지시하고 기다리게 됩니다. 기다리는 동안 Process A가 CPU 제어권을 가질 time slice가 지난 경우(HW의 timer interrupt와 스케줄러에 의해 time slice가 결정됩니다.) `read`를 기다리는 동안에 Process B로 context switching이 발생합니다. Process B의 user code가 수행되는 동안 Disk I/O가 종료되었고 disk controller는 disk interrupt를 발생시키게 됩니다.

Disk interrupt가 발생했을 때 어떤 프로세스로 전환될지는 스케줄러 정책에 따라 달라질 수 있습니다. 예를 들어, 커널이 즉시 Process A를 깨워 재개할 수도 있고, 우선순위나 정책에 따라 Process B를 조금 더 실행한 뒤에 Process A로 돌아갈 수도 있습니다. 여기서는 단순화를 위해, interrupt 처리 후 적절한 시점에 Process A가 다시 스케줄되어 `read`가 완료되는 흐름을 생각하면 됩니다.


## Review

여기서는 간단한 예제를 풀어보면서 이해도를 점검해보는 시간을 가져보겠습니다.

### 예제1
Consider three processed with the following starting and ending times.

|Process|Start time|End time|
|---|---|---|
| A | 1 | 3 |
| B | 2 | 5 |
| C | 4 | 6 | 

For each pair of processes, indicate whether they run concurrently or not.

|Process pair|Concurrent?|
|---|---|
|AB||
|AC||
|BC||

위 문제는 각 프로세스의 시작 시간과 종료 시간이 주어졌을 때, 동시에 실행된 짝을 찾으면 되는 문제입니다.
아래처럼 그림을 간단하게 그려보면 답이 바로나오게 됩니다.
우선 AB,BC는 서로 동시에 실행되는 것이고 AC는 시간이 겹치는 것이 없기 때문에 동시에 실행된 것이 아닙니다.

![alt text](/assets/images/2025-12-4-ch8-2-process/sol1.png)



