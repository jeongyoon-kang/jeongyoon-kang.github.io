---
layout: single
title: "Exceptional Control Flow(ECF) - Process"
categories: system-sw 
---

# Process

안녕하세요. 이번 포스팅은 ECF: Introduction의 다음편인 Process편입니다.

<br>

## 프로그램 실행의 환상과 현실

현대 컴퓨터에서 프로그램을 실행할 때, 우리는 마치 그 프로그램이 프로세서와 메모리를 독점하여 사용하는 것처럼 느낍니다. 예를 들어 윈도우에서 Word 프로그램으로 문서 작업을 하고 있다면, 프로세서가 Word의 명령어들을 순차적으로, 중단 없이 실행하는 것처럼 보입니다.

하지만 이것은 **운영체제가 제공하는 정교한 추상화**입니다. 실제로는 그 이면에서 OS kernel이 끊임없이 동작하고 있습니다:

- 키보드와 마우스 입력에 대한 **interrupt handler**가 실행됩니다
- 가상 메모리 시스템의 **page fault handler**가 필요한 페이지를 메모리에 적재합니다
- 다른 프로그램들로의 **context switching**이 사용자 눈에 보이지 않게 발생합니다

이 모든 것이 우리 눈에 보이지 않게 일어나면서, Word 프로그램만 실행되고 있다는 착각을 제공합니다.

### 질문: 동시성과 병렬성

여기서 한 가지 생각해볼 질문이 있습니다:

> **"여러 프로그램이 동시에 실행된다"는 것의 의미는 무엇일까요?**

전통적인 운영체제 이론에서는 **싱글 프로세서** 환경을 가정하고, context switching을 통해 여러 프로그램이 마치 동시에 실행되는 것처럼 보이게 합니다. 하지만 실제로는 어느 한 순간에 하나의 프로그램만 실행되고, OS가 매우 빠르게 전환하면서 동시 실행의 환상을 만들어냅니다.

반면 현대 시스템은 **멀티 프로세서/멀티 코어** 환경이 주류입니다. 이 경우:

- 일부 프로그램들은 **실제로 동시에(parallel)** 실행됩니다
- 하지만 실행 중인 프로그램 수가 CPU 코어 수보다 많다면, 여전히 일부는 **동시에 실행되는 것처럼 보이는(concurrent)** 것입니다
- 즉, 진정한 병렬성(parallelism)과 시분할에 의한 동시성(concurrency)이 함께 존재합니다

## 이번 포스팅에서 다룰 내용

이번 포스팅에서는 운영체제의 모든 메커니즘을 다루지는 않지만, 프로세스라는 추상화의 핵심 개념들을 살펴봅니다:

1. **독립적 논리 제어 흐름(Logical Control Flow)**: 프로그램이 프로세서를 독점한다는 착각을 제공
2. **사적 주소 공간(Private Address Space)**: 프로그램이 메모리를 독점한다는 착각을 제공

이러한 추상화들이 어떻게 동작하고, 왜 중요한지 함께 알아보겠습니다. 


## Logical Control Flow

각 프로세스는 시스템에 여러 프로그램들이 동시에 동작하고 있음에도 불구하고, 마치 프로세서를 혼자서 사용하는 것처럼 느낍니다.<br> 만일 프로그램의 실행을 단일 스텝으로 실행하기 위해서 debugger를 사용하면, executable object 내에 들어 있거나 runtime에 동적으로 링크된 shared object 내에 있는 instruction에 PC (Program Counter) 값들이 대응되는 것을 관찰할 수 있습니다.<br> 이런 PC 값들의 배열을 논리적 제어흐름 또는 간단히 논리흐름이라고 부릅니다.

아래 그림은 단일 프로세서에서 세 개의 프로세스를 실행하는 시스템에 대해 표현한 것입니다.<br> 이 프로세서에서 물리적인 제어흐름은 프로세서에 대해서 한 개씩 세 개의 논리흐름으로 나누어집니다.<br> 각 수직선은 어떤 프로세스에 대한 논리적인 흐름의 일부를 나타냅니다.<br> 아래 그림에서 이 세 개의 논리 흐름은 서로 중첩되지 않습니다. (단일 프로세서에 대해 생각하는 것이므로) 

아래 그림의 요점은 하나의 프로세서를 사용해서 여러 프로세스들이 교대로 돌아간다는 점입니다.<br> 각 프로세스는 자신의 흐름 일부분을 실행하고 나서 다른 프로세스들로 순서를 바꾸어 실행되는 동안 선점됩니다. (mean: 선점된다 → 일시적으로 정지된다.) <br>이 프로세스들 중에서 하나의 context에서 실행되는 프로그램은 마치 프로세서를 배타적으로 소유한 것처럼 보입니다. 

![alt text](/assets/images/2025-12-4-ch8-2-process/logical_control_flow.png)

## Concurrent Flow

논리흐름은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 가집니다. Exception handler, Process, Signal handler, Thread는 모두 논리흐름의 예시입니다.

자신의 실행시간이 다른 흐름과 겹치는 논리흐름을 *동시성 흐름 (Concurrent Flow)*이라고 부릅니다.<br> 이 두 흐름은 동시에 실행된다고 말합니다. 위 그림에서 Process A와 Process B는 동시에 실행되는 상황이고, Process B와 Process C는 동시에 실행되는 것이 아닙니다.<br> 왜냐하면 B의 마지막 instruction이 C의 첫 번째 instruction 전에 실행되기 때문입니다.

여러 흐름이 동시에 실행되는 현상을 *동시성 (Concurrency)*이라고 말합니다.<br> 또한 프로세스가 다른 프로세스들과 교대로 실행된다는 개념은 *multitasking*이라고 말합니다.<br> 한 프로세스가 자신의 흐름 일부를 실행하는 매 시간 주기를 *time slice*라고 합니다.<br> 그래서 *multitasking*을 *time slicing*이라고 부르기도 합니다.<br> 위 그림에서 Process A에 대한 흐름은 2개의 time slice로 구성됩니다.<br>

동시성 흐름에 대한 개념은 시스템의 프로세서 코어 수나 프로세서 갯수와는 무관합니다. <br>만일 두 흐름이 시간상으로 중첩되면 동시적으로 실행되는 것입니다. <br>프로세서의 어느 한 코어에서 2 개의 프로세스가 실행된다고 해도 시간상 중첩되면 동시적이라고 할 수 있습니다. <br>하지만 여기서 구별해야하는 중요한 개념이 있습니다. <br>바로 *병렬 흐름 (parallel flows)* 입니다. <br>만일 2개의 process가 서로 다른 프로세서 코어나 프로세서(numa)에서 동시에 돌아가고 있다면 이는 동시 실행이자, 병렬 실행입니다.

## Private Address Space

